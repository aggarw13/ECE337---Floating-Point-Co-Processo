##############################################################################
# ECE 337 General Makefile
# 
# Set tab spacing to 2 spaces per tab for best viewing results
##############################################################################

# Include the common/shared variables for the course to minimize potentially stale values
# Note: the release_make_vars already includes the common/public ones
include /home/ecegrid/a/ece337/Course_Prod/course_make_vars

##############################################################################
# File Related Variables
##############################################################################

# Fill in the appropriate filenames for the Phase 1 submodule code files (without the 'source/')
# The contents of these variables must be plain text (no functions or variable references)
#SCL_EDGE_FILE	:= scl_edge.sv
#SDA_SEL_FILE	:= sda_sel.sv
#DECODE_FILE		:= decode.sv
#TX_FIFO_FILE	:= tx_fifo.sv

# Fill in the appropriate filenames for the Phase 1 submodule test benches (without the 'source/')
# The contents of these variables must either be plain text (no functions or variable references)
# or references to the Phase 1 submodule code file variables
TB_SCL_EDGE_FILE	:= tb_$(SCL_EDGE_FILE)
TB_SDA_SEL_FILE		:= tb_$(SDA_SEL_FILE)
TB_DECODE_FILE		:= tb_$(DECODE_FILE)
TB_TX_FIFO_FILE		:= tb_$(TX_FIFO_FILE)

# Fill in the names of any test bench helper code files (code files referenced by your testbenches
# other than the actual design files)( do not include the 'source/') (filenames must start with 'tb_')
TB_HELPER_FILES	:= 

# List internal component/block files here (separate the filenames with spaces)
# (do not include the source folder in the name)
# NOTE: YOU WILL NEED TO SET THIS VARIABLE'S VALUE WHEN WORKING WITH HEIRARCHICAL DESIGNS
# AND THE AUTOMATED GRADING SYSTEM
# The contents of these variables must either be plain text (no functions or variable references)
# or references to the Phase 1 submodule code file variables
#COMPONENT_FILES	:= $(SCL_EDGE_FILE) $(SDA_SEL_FILE) $(DECODE_FILE) $(TX_FIFO_FILE)
#COMPONENT_FILES += tx_sr.sv rx_sr.sv controller.sv timer.sv
#COMPONENT_FILES += flex_counter.sv flex_stp_sr.sv flex_pts_sr.sv
COMPONENT_FILES := signMul.sv mul24.sv exponentAdd.sv normalizeMul.sv
COMPONENT_FILES += sticky.sv roundMul.sv exponentUp.sv
#COMPONENT_FILES	:= CLA_24bit.sv exp_diff.sv exp_mux.sv inversion_mux.sv bit_inversion.sv round.sv shifter.sv LOP_nbit.sv LOD.sv LOD_2bit.sv LOD_nbit.sv comparator.sv swap.sv Sign.sv exception_handling.sv barrel_mux.sv
COMPONENT_FILES	+= CLA_24bit.sv exp_diff.sv exp_mux.sv inversion_mux.sv bit_inversion.sv round.sv shifter.sv LOP_nbit.sv LOD.sv LOD_2bit.sv LOD_nbit.sv comparator.sv swap.sv Sign.sv exception_handling.sv barrel_mux.sv
COMPONENT_FILES += multiply.sv add_block.sv 

# Specify the name of the top level file (do not include the source folder in the name)
# NOTE: YOU WILL NEED TO SET THIS VARIABLE'S VALUE WHEN WORKING WITH HEIRARCHICAL DESIGNS
# AND THE AUTOMATED GRADING SYSTEM
#TOP_LEVEL_FILE	:= i2c_slave.sv
#TOP_LEVEL_FILE := multiply.sv
#TOP_LEVEL_FILE	:= add_block.sv
TOP_LEVEL_FILE := sine.sv

# Specify the filename of the test bench you want to use (without the 'source/')
TEST_BENCH	:= tb_$(TOP_LEVEL_FILE)

# Get the top level design and test_bench module names
TB_MODULE		:= $(notdir $(basename $(TEST_BENCH)))
TOP_MODULE	:= $(notdir $(basename $(TOP_LEVEL_FILE)))

# Select the Cell Library to use with simulations
GATE_LIB		:= $(AMI_05_LIB)

S_WORK_LIB := source_work
M_WORK_LIB := mapped_work

# Automatically handle whether to running on the grid or not
LIB_CREATE	:= vlib
COMPILE 		:= vlog -sv
SIMULATE		:= vsim -Lf $(LABS_IP_LIB) -L $(GATE_LIB) +no_glitch_msg -coverage
DC_SHELL		:= dc_shell-t

##############################################################################
# Designate that all "intermediate" files created during chaing make rules
# should not be deleted (otherwise automatically compiled or synthesized files
# will be automatically deleted by make after it's done with them).
##############################################################################
.SECONDARY:

##############################################################################
# Designate targets that do not correspond directly to files so that they are
# run every time they are called
##############################################################################
.phony: default clean veryclean
.phony: print_vars
.phony: sim_full_source sim_full_mapped
.phony: syn_mapped

##############################################################################
# Make the default target (the one called when no specific one is invoked) to
# output the proper usage of this makefile
##############################################################################
default:
	@echo "----------------------------------------------------------------"
	@echo "Administrative targets:"
	@echo "  clean         - removes the temporary files"
	@echo	"  very_clean    - removes the mapped files as well"
	@echo	"  print_vars    - prints the contents of the variables"
	@echo
	@echo "Compilation targets:"
	@echo "  source_%     - compiles the source version of an indivudal file"
	@echo "                 with the basename of % and outputs the feedback"
	@echo "                 to the terminal instead of to a log file"
	@echo "  mapped_%     - compiles the mapped version of an indivudal file"
	@echo "                 with the basename of % and outputs the feedback"
	@echo "                 to the terminal instead of to a log file"
	@echo "  mapped_tb_%  - compiles the testbench for an indivudal mapped file"
	@echo "                 with the basename of % and outputs the feedback"
	@echo "                 to the terminal instead of to a log file"
	@echo
	@echo "Simulation targets:"
	@echo "  sim_full_source   - compiles and simulates the source version"
	@echo "                      of a full design including its top level"
	@echo "                      test bench"
	@echo "  sim_full_mapped   - compiles and simulates the mapped version"
	@echo "                      of a full design including its top level"
	@echo "                      test bench"
	@echo "  sim_%_source      - compiles and simulates the source version"
	@echo "                      of an individual file with basename %"
	@echo "                      without a testbench"
	@echo "  sim_%_mapped      - compiles and simulates the mapped version"
	@echo "                      of an individual file with basename %"
	@echo "                      without a testbench"
	@echo "  tbsim_%_source    - compiles and simulates the source version"
	@echo "                      of an individual file with basename %"
	@echo "                      with its testbench"
	@echo "  tbsim_%_mapped    - compiles and simulates the mapped version"
	@echo "                      of an individual file with basename %"
	@echo "                      with its testbench"
	@echo 
	@echo "Synthesis targets:"
	@echo "  mapped/%   - synthesizes the mapped version of an individual file"
	@echo "               additionally the DEP_SUB_FILES variabl can be used "
	@echo "               to define dependant submodule files needed for "
	@echo "               synthesis and the CLOCK_NAME variable can be used"
	@echo "               to define the clock signal name to use for synthesis"
	@echo "               of sequential/clocked designs"
	@echo "----------------------------------------------------------------"

##############################################################################
# Target Intercept for working with the Grid
##############################################################################
ifeq ($(shell hostname),ecegrid-lnx.ecn.purdue.edu)
# Currently make is running from the grid front-end -> Intercept and grid the whole make run at once
# Only run when the pattern/target matches the first target/goal in the list to preven duplicate passes
# and keep the whole make run on one grid backend server instance
%:
	@$(if $(findstring $@, $(word 1, $(MAKECMDGOALS))), grid $(MAKE) $(MAKECMDGOALS) -$(MAKEFLAGS))
# Else don't do anything because all targets/goals should have already been grided with the first run
else
# Not on the grid front end -> Use the normal makefile contents

##############################################################################
# Administrative Targets
##############################################################################

clean:
	@echo -e "Removing temporary files"
	@rm -rf *_work
	@rm -rf analyzed/ARCH analyzed/ENTI
	@rm -f analyzed/*
	@rm -f schematic/*
	@rm -f *.wlf *.svf transcript
	@rm -f *.tran
	@rm -f *.scomp *.mcomp
	@echo -e "Done\n\n"
	
veryclean:
	@$(MAKE) --no-print-directory clean
	@echo -e "Removing synthesized files, synthesis logs, and synthesis reports"
	@rm -f mapped/*
	@rm -f reports/*
	@rm -f *.log
	@echo -e "Done\n\n"

print_vars:
	@echo -e "Component Files: \n $(foreach file, $(COMPONENT_FILES), $(file)\n)"
	@echo -e "Top level File: $(TOP_LEVEL_FILE)"
	@echo -e "Testbench: $(TEST_BENCH)"
	@echo -e "Top level module: $(TOP_MODULE)"
	@echo -e "Testbench module: $(TB_MODULE)"
	@echo -e "Gate Library: '$(GATE_LIB)'"
	@echo -e "Gold Library: '$(GOLD_LIB)'"
	@echo -e "Course Library: '$(COURSE_LIB)'"
	@echo -e "Source work library: '$(S_WORK_LIB)'"
	@echo -e "Mapped work library: '$(M_WORK_LIB)'"
	
##############################################################################
# Compilation Targets
##############################################################################

# Define a pattern rule to automatically create the work library for a design source compile
$(S_WORK_LIB):
	@echo -e "Creating work library: $@"
	@rm -rf $@
	@$(LIB_CREATE) $@

# Define a pattern rule to automatically compile updated source files for a design
$(S_WORK_LIB)/%: source/%.sv $(S_WORK_LIB)
	@echo -e "Compiling '$<' into work library '$(word 2, $^)'"
	@rm -rf $@
	@$(COMPILE) -work $(word 2, $^) $< > $*.scomp
	@echo -e "Done compiling '$<' into work library '$(word 2, $^)'"

# Define a pattern rule to for use at commandline to compile source versions and
# send feedback to terminal instead of log file
source_%: source/%.sv $(S_WORK_LIB)
	@echo -e "Compiling '$<' into work library '$(word 2, $^)'"
	@rm -rf $(word 2, $^)/$*
	@$(COMPILE) -work $(word 2, $^) $<
	@echo -e "Done compiling '$<' into work library '$(word 2, $^)'"

# Define a pattern rule to automatically create the work library for a full design mapped compile
$(M_WORK_LIB):
	@echo -e "Creating work library: $@"
	@rm -rf $@
	@$(LIB_CREATE) $@
	
# Define a pattern rule to automatically compile updated mapped design files for a full mapped design
$(M_WORK_LIB)/%: mapped/%.v $(M_WORK_LIB)
	@echo -e "Compiling '$<' into work library '$(word 2, $^)'"
	@rm -rf $@
	@$(COMPILE) -work $(word 2, $^) $< > $*.mcomp
	@echo -e "Done compiling '$<' into work library '$(word 2, $^)'"

# Define a pattern rule to automatically compile updated test bench files for a full mapped design
$(M_WORK_LIB)/tb_%: source/tb_%.sv $(M_WORK_LIB)
	@echo -e "Compiling '$<' into work library '$(word 2, $^)'"
	@rm -rf $@
	@$(COMPILE) -work $(word 2, $^) $< > $*.mcomp
	@echo -e "Done compiling '$<' into work library '$(word 2, $^)'"

# Define a pattern rule to for use at commandline to compile mapped versions and
# send feedback to terminal instead of log file
mapped_%: mapped/%.v $(M_WORK_LIB)
	@echo -e "Compiling '$<' into work library '$(word 2, $^)'"
	@rm -rf $(word 2, $^)/$*
	@$(COMPILE) -work $(word 2, $^) $<
	@echo -e "Done compiling '$<' into work library '$(word 2, $^)'"

# Define a pattern rule to for use at commandline to compile testbenches for mapped
# versions and send feedback to terminal instead of log file
mapped_tb_%.sv: source/tb_%.sv $(M_WORK_LIB)
	@echo -e "Compiling '$<' into work library '$(word 2, $^)'"
	@rm -rf $(word 2, $^)/tb_$*
	@$(COMPILE) -work $(word 2, $^) $<
	@echo -e "Done compiling '$<' into work library '$(word 2, $^)'"

##############################################################################
# Simulation Targets
##############################################################################
define CONSOLE_SIM_CMDS
"run 15 us;	\
 quit -f"
endef

# This rule defines how to simulate the source form of the full design
sim_full_source: $(addprefix $(S_WORK_LIB)/, $(basename $(TOP_LEVEL_FILE) $(TEST_BENCH) $(TB_HELPER_FILES) $(COMPONENT_FILES)))
	@echo -e "Simulating Source Design"
# Uncomment below if you want to just run the simulation as a console command
# using the commands listed in the CONSOLE_SIM_CMDS definition above instead of 
# .do file and have the transcript contents to be saved to a file
#	@$(SIMULATE) -c -t ps -do $(CONSOLE_SIM_CMDS) $(S_WORK_LIB).$(TB_MODULE) > source.tran

# Uncomment below if you want run the simulation the normal way and have it
# run the specified .do file
#	@$(SIMULATE) -t ps -do s_waves.do $(S_WORK_LIB).$(TB_MODULE)

# This way just runs it like normal and only sets up the simulation but doesn't
# run it or add any waveforms
	@$(SIMULATE) -i -t ps $(S_WORK_LIB).$(TB_MODULE)
	@echo -e "Done simulating the source design\n\n"

# This rule defines how to simulate the mapped form of the full design
sim_full_mapped: $(addprefix $(M_WORK_LIB)/, $(basename $(TOP_LEVEL_FILE) $(TEST_BENCH) $(TB_HELPER_FILES)))
	@echo -e "Simulating Mapped Design"
# Uncomment below if you want to just run the simulation as a console command
# using the commands listed in the CONSOLE_SIM_CMDS definition above instead of 
# .do file and have the transcript contents to be saved to a file
#	@$(SIMULATE) -c -t ps -do $(CONSOLE_SIM_CMDS) $(M_WORK_LIB).$(TB_MODULE) > mapped.tran

# Uncomment below if you want run the simulation the normal way and have it
# run the specified .do file
#	@$(SIMULATE) -t ps -do s_waves.do $(M_WORK_LIB).$(TB_MODULE)

# This way just runs it like normal and only sets up the simulation but doesn't
# run it or add any waveforms
	@$(SIMULATE) -i -t ps $(M_WORK_LIB).$(TB_MODULE)
	@echo -e "Done simulating the mapped design\n\n"

# Define a pattern rule for simulating the source version of individual files	without a testbench
sim_%_source: $(S_WORK_LIB)/%
	@$(SIMULATE) -i -t ps $(dir $<).$*
	
# Define a pattern rule for simulating the mapped version of individual files	without a testbench
sim_%_mapped: $(M_WORK_LIB)/%
	@$(SIMULATE) -i -t ps $(dir $<).$*
	
# Define a pattern rule for simulating the source version of individual files	with a testbench
tbsim_%_source: $(S_WORK_LIB)/% $(S_WORK_LIB)/tb_% $(if $(TB_HELPER_FILES), $(addprefix $(S_WORK_LIB)/,$(TB_HELPER_FILES)))
	@$(SIMULATE) -i -t ps $(dir $<).tb_$*

# Define a pattern rule for simulating the mapped version of individual files	with a testbench
tbsim_%_mapped: $(M_WORK_LIB)/% $(M_WORK_LIB)/tb_% $(if $(TB_HELPER_FILES), $(addprefix $(M_WORK_LIB)/,$(TB_HELPER_FILES)))
	@$(SIMULATE) -i -t ps $(dir $<).tb_$*

##############################################################################
# Define the synthesis target specific variables to use
##############################################################################

# Set the default value of the clock name and clock period to an empty string so that clock timing will
# only be activated in the SYN_CMDS definition if they were overwritten at invocation
CLOCK_NAME 		:= clk
CLOCK_PERIOD	:= 5
INPUT_DELAY     := 0.1

# Set the default value of the source files for sub modules to be an empty string so that
# it will only be used if overwritten at invocation
DEP_SUB_FILES :=

# Set the default value of the main source file to an empty string since it will be
# overwritten by each rule where it is used anyways
MAIN_FILE :=

# Set the module's name to always be the same as the basename of the file
# (a.k.a. the file name without the file extension)
MOD_NAME := $(basename $(MAIN_FILE))

##############################################################################
# Synthesis Targets
##############################################################################

# A customized make target for the top level file for complex designs
# Note: The CLOCK_NAME variable override below will need to be set to the actual
# clock signal name for sequential/clocked designs.
mapped/$(TOP_MODULE).v: SHELL := /usr/local/bin/tcsh
mapped/$(TOP_MODULE).v: source/$(TOP_LEVEL_FILE) $(addprefix source/,$(COMPONENT_FILES))
	@echo "Synthesizing design: $@\n"
	@$(MAKE) --no-print-directory syn_mapped MAIN_FILE='$(TOP_LEVEL_FILE)' DEP_SUB_FILES='$(COMPONENT_FILES)' CLOCK_NAME='clk' CLOCK_PERIOD='$(CLOCK_PERIOD)' > $(TOP_MODULE).log
	@echo "Synthesis run attempt for $@ complete"
	@echo "Checking synthesis attempt for errors"
	@syschk -w $(TOP_MODULE)
	@echo "\nCheck for synthesis attempt errors complete, open $(TOP_MODULE).log for details if errors were found"
	@echo "\nRemember to check $(TOP_MODULE).log for latches and timing arcs"
	@echo "Synthesis run complete for design: $@\n\n"

# A pattern rule target to synthesize any design that does not already have one defined earlier,
# as long as the desired mapped file has a corresponding source file with the same basename,
# (which is grabbed by the '%' and accessed via the $* automatic variable).
# Additionally it will include any specified dependant submodule source files in the target's
# dependencies and thus will resynthesize if any of them are newer as well.
# It will pass on any of the related variables values if they were overwritten at runtime.
mapped/%.v: SHELL := /usr/local/bin/tcsh
mapped/%.v: source/%.sv $(addprefix source/,$(DEP_SUB_FILES))
	@echo "Synthesizing design: $@\n"
	@$(MAKE) --no-print-directory syn_mapped MAIN_FILE='$*.sv' DEP_SUB_FILES='$(DEP_SUB_FILES)' CLOCK_NAME='$(CLOCK_NAME)' CLOCK_PERIOD='$(CLOCK_PERIOD)' > $*.log
	@echo "Synthesis run attempt for $@ complete"
	@echo "Checking synthesis attempt for errors"
	@syschk -w $*
	@echo "\nCheck for synthesis attempt errors complete, open $*.log for details if errors were found"
	@echo "\nRemember to check $*.log for latches and timing arcs"
	@echo "Synthesis run complete for design: $@\n\n"

##############################################################################
# Define the synthesis commands to use
##############################################################################
	
define SYN_CMDS
'# Step 1:  Read in the source file                                                     \n\
analyze -format sverilog -lib WORK {$(DEP_SUB_FILES) $(MAIN_FILE)}        						  \n\
elaborate $(MOD_NAME) -lib WORK -update                       										  		\n\
                                                                                        \n\
uniquify                                                                                \n\
# Step 2: Set design constraints                                                        \n\
# Uncomment below to set timing, area, power, etc. constraints                          \n\
# set_max_delay <delay> -from "<input>" -to "<output>"                                  \n\
# set_max_area <area>                                                                   \n\
# set_max_total_power <power> mW                                                        \n\
$(if $(and $(CLOCK_NAME), $(CLOCK_PERIOD)), create_clock "$(CLOCK_NAME)" -name "$(CLOCK_NAME)" -period $(CLOCK_PERIOD)) \n\
set_input_delay -clock "$(CLOCK_NAME)" "$(INPUT_DELAY)" [all_inputs]                              \n\
set_max_delay 2.0 -from "MULX2/MUL/a[2]" -to "MULX2/MUL/result[47]"                                                                      \n\
set_max_delay 0.5 -from "MULX2/NORM/result[47]" -to "MULX2/NORM/mantissa[22]"								\n\
set_max_delay 1.2 -from "MULX2/STICK/rest[0]" -to "MULX2/STICK/S"					\n\
set_max_delay 2.0 -from "MULX2/RND/L" -to "MULX2/RND/rounded[22]"						\n\
set_max_delay 2.0 -from "MULX2/EADD/exp1[0]" -to "MULX2/EADD/result[7]"					\n\
set_max_delay 2.0 -from "MULX3/MUL/a[2]" -to "MULX3/MUL/result[47]"                                                                      \n\
set_max_delay 0.5 -from "MULX3/NORM/result[47]" -to "MULX3/NORM/mantissa[22]"								\n\
set_max_delay 1.2 -from "MULX3/STICK/rest[0]" -to "MULX3/STICK/S"					\n\
set_max_delay 2.0 -from "MULX3/RND/L" -to "MULX3/RND/rounded[22]"						\n\
set_max_delay 2.0 -from "MULX3/EADD/exp1[0]" -to "MULX3/EADD/result[7]"					\n\
set_max_delay 2.0 -from "MULX5/MUL/a[2]" -to "MULX5/MUL/result[47]"                                                                      \n\
set_max_delay 0.5 -from "MULX5/NORM/result[47]" -to "MULX5/NORM/mantissa[22]"								\n\
set_max_delay 1.2 -from "MULX5/STICK/rest[0]" -to "MULX5/STICK/S"					\n\
set_max_delay 2.0 -from "MULX5/RND/L" -to "MULX5/RND/rounded[22]"						\n\
set_max_delay 2.0 -from "MULX5/EADD/exp1[0]" -to "MULX5/EADD/result[7]"					\n\
set_max_delay 2.0 -from "MULX3FAC/MUL/a[2]" -to "MULX3FAC/MUL/result[47]"                                                                      \n\
set_max_delay 0.5 -from "MULX3FAC/NORM/result[47]" -to "MULX3FAC/NORM/mantissa[22]"								\n\
set_max_delay 1.2 -from "MULX3FAC/STICK/rest[0]" -to "MULX3FAC/STICK/S"					\n\
set_max_delay 2.0 -from "MULX3FAC/RND/L" -to "MULX3FAC/RND/rounded[22]"						\n\
set_max_delay 2.0 -from "MULX3FAC/EADD/exp1[0]" -to "MULX3FAC/EADD/result[7]"					\n\
set_max_delay 2.0 -from "MULX7/MUL/a[2]" -to "MULX7/MUL/result[47]"                                                                      \n\
set_max_delay 0.5 -from "MULX7/NORM/result[47]" -to "MULX7/NORM/mantissa[22]"								\n\
set_max_delay 1.2 -from "MULX7/STICK/rest[0]" -to "MULX7/STICK/S"					\n\
set_max_delay 2.0 -from "MULX7/RND/L" -to "MULX7/RND/rounded[22]"						\n\
set_max_delay 2.0 -from "MULX7/EADD/exp1[0]" -to "MULX7/EADD/result[7]"					\n\
set_max_delay 2.0 -from "MULX5FAC/MUL/a[2]" -to "MULX5FAC/MUL/result[47]"                                                                      \n\
set_max_delay 0.5 -from "MULX5FAC/NORM/result[47]" -to "MULX5FAC/NORM/mantissa[22]"								\n\
set_max_delay 1.2 -from "MULX5FAC/STICK/rest[0]" -to "MULX5FAC/STICK/S"					\n\
set_max_delay 2.0 -from "MULX5FAC/RND/L" -to "MULX5FAC/RND/rounded[22]"						\n\
set_max_delay 2.0 -from "MULX5FAC/EADD/exp1[0]" -to "MULX5FAC/EADD/result[7]"					\n\
set_max_delay 2.0 -from "MULX7FAC/MUL/a[2]" -to "MULX7FAC/MUL/result[47]"                                                                      \n\
set_max_delay 0.5 -from "MULX7FAC/NORM/result[47]" -to "MULX7FAC/NORM/mantissa[22]"								\n\
set_max_delay 1.2 -from "MULX7FAC/STICK/rest[0]" -to "MULX7FAC/STICK/S"					\n\
set_max_delay 2.0 -from "MULX7FAC/RND/L" -to "MULX7FAC/RND/rounded[22]"						\n\
set_max_delay 2.0 -from "MULX7FAC/EADD/exp1[0]" -to "MULX7FAC/EADD/result[7]"					\n\
set_max_delay 0.8 -from "ADDX3/MANT_CMPR/b[0]" -to "ADDX3/MANT_CMPR/gt"                                                 \n\
set_max_delay 2.0 -from "ADDX3/LRGEMANT_INV/inversion_control" -to "ADDX3/LRGEMANT_INV/updated_mantissa[23]"                   \n\
set_max_delay 0.4 -from "ADDX3/SMLLMANT_SHIFT/mant_shift[7]" -to "ADDX3/SMLLMANT_SHIFT/shifted_mantissa[17]"                      \n\
set_max_delay 0.9 -from "ADDX3/MANT_ADD/a[0]" -to "ADDX3/MANT_ADD/sum[23]"                                            \n\
set_max_delay 1.0 -from "ADDX3/LZC_PREDICT/op1[19]" -to "ADDX3/LZC_PREDICT/shift[4]"                                         \n\
set_max_delay 1.0 -from "ADDX3/ROUND_RES/eop" -to "ADDX3/ROUND_RES/rnd_result[22]"                                      \n\
set_max_delay 0.94 -from "ADDX3/EXCPETIONS/ovf" -to "ADDX3/EXCPETIONS/exp[7]"                                              \n\
set_max_delay 0.8 -from "ADDX5/MANT_CMPR/b[0]" -to "ADDX5/MANT_CMPR/gt"                                                 \n\
set_max_delay 2.0 -from "ADDX5/LRGEMANT_INV/inversion_control" -to "ADDX5/LRGEMANT_INV/updated_mantissa[23]"                   \n\
set_max_delay 0.4 -from "ADDX5/SMLLMANT_SHIFT/mant_shift[7]" -to "ADDX5/SMLLMANT_SHIFT/shifted_mantissa[17]"                      \n\
set_max_delay 0.9 -from "ADDX5/MANT_ADD/a[0]" -to "ADDX5/MANT_ADD/sum[23]"                                            \n\
set_max_delay 1.0 -from "ADDX5/LZC_PREDICT/op1[19]" -to "ADDX5/LZC_PREDICT/shift[4]"                                         \n\
set_max_delay 1.0 -from "ADDX5/ROUND_RES/eop" -to "ADDX5/ROUND_RES/rnd_result[22]"                                      \n\
set_max_delay 0.94 -from "ADDX5/EXCPETIONS/ovf" -to "ADDX5/EXCPETIONS/exp[7]"                                              \n\
set_max_delay 0.8 -from "ADDX7/MANT_CMPR/b[0]" -to "ADDX7/MANT_CMPR/gt"                                                 \n\
set_max_delay 2.0 -from "ADDX7/LRGEMANT_INV/inversion_control" -to "ADDX7/LRGEMANT_INV/updated_mantissa[23]"                   \n\
set_max_delay 0.4 -from "ADDX7/SMLLMANT_SHIFT/mant_shift[7]" -to "ADDX7/SMLLMANT_SHIFT/shifted_mantissa[17]"                      \n\
set_max_delay 0.9 -from "ADDX7/MANT_ADD/a[0]" -to "ADDX7/MANT_ADD/sum[23]"                                            \n\
set_max_delay 1.0 -from "ADDX7/LZC_PREDICT/op1[19]" -to "ADDX7/LZC_PREDICT/shift[4]"                                         \n\
set_max_delay 1.0 -from "ADDX7/ROUND_RES/eop" -to "ADDX7/ROUND_RES/rnd_result[22]"                                      \n\
set_max_delay 0.94 -from "ADDX7/EXCPETIONS/ovf" -to "ADDX7/EXCPETIONS/exp[7]"                                              \n\
                                                                                        \n\
# Step 3: Compile the design                                                            \n\
compile -map_effort medium                                                              \n\
                                                                                        \n\
# Step 4: Output reports                                                                \n\
report_timing -path full -delay max -max_paths 1 -nworst 1 > reports/$(MOD_NAME).rep    \n\
report_area >> reports/$(MOD_NAME).rep                                                  \n\
report_power -hier >> reports/$(MOD_NAME).rep                                           \n\
                                                                                        \n\
# Step 5: Output final VHDL and Verilog files                                           \n\
write -format verilog -hierarchy -output "mapped/$(MOD_NAME).v"                         \n\
echo "\\nScript Done\\n"                                                                \n\
echo "\\nChecking Design\\n"                                                            \n\
check_design                                                                            \n\
exit'
endef

# Define the target that will actuall invoke the synthesis commands through design compiler
# Use of the .ONESHELL will cause all of the lines after the DC_SHELL invocation line to be
# run on the design compiler shell instance created by the DC_SHELL invocation line.
syn_mapped:
	@echo -e "Synthesizing design: $(MAIN_FILE)"
	@echo -e $(SYN_CMDS) | $(DC_SHELL)
	@echo -e "Done\n\n"

# Need for the Grid Target interception
endif
